static char src_id [] = "$Header: /home/commsa/cmdv/cmss/src/RCS/circfile.c,v 1.16 2002/06/14 06:02:54 ace Exp $";
/**
* 	circfile -- Ansi-C circular files toolkit.
*
****************************************************************************
*
* FUNCTION	CIRCFILE -- a Circular File toolkit.
*
* PROTOTYPE IN	circfile.h
*
* SUMMARY	
*	#include "circfile.h"
*	int circfile_Init (CIRCFILE *c);
*	int circfile_NotInit (CIRCFILE *c);
*	int circfile_Close (CIRCFILE *c);
*	int circfile_SetSyncWrites (CIRCFILE *c, const int yesno);
*	int circfile_SetDirectory (CIRCFILE *c, const char *homedir);
*	int circfile_Create (CIRCFILE *c, const char *prefix, 
*				const int max_records, const int record_size);
*	int circfile_CreateMultiFile (CIRCFILE *c, const char *prefix, 
*				const int max_records, const int record_size,
*				const int records_per_file);
*	int circfile_SetToMultiFile (CIRCFILE *c, const int records_per_file);
*	int circfile_SaveTraceMessages (CIRCFILE *c, const int yesno);
*	int circfile_OpenReader (CIRCFILE *c, const char *prefix);
*	int circfile_OpenWriter (CIRCFILE *c, const char *prefix);
*	int circfile_OpenWriteOnly (CIRCFILE *c, const char *prefix);
*	int circfile_OpenLooker (CIRCFILE *c, const char *prefix);
*	int circfile_SetUnlockedReads (CIRCFILE *c);
*	int circfile_SetUnlockedWrites (CIRCFILE *c);
*	int circfile_SetStoreRecordno (CIRCFILE *c, void *record, 
*						void *record_recno);
*	int circfile_DiscardUnreadRecords (CIRCFILE *c);
*	int circfile_ResetNtbr (CIRCFILE *c, const int ntbr);
*	int circfile_ResetNtbw (CIRCFILE *c, const int ntbw);
*	int circfile_ResetMaxRecords (CIRCFILE *c, const int max_records);
*	int circfile_LookRecord (CIRCFILE *c, void *record,const int record_no);
*	int circfile_RewriteRecord (CIRCFILE *c, void *record,
*						 const int record_no);
*	int circfile_ReadUpdate (CIRCFILE *c, void *record);
*	int circfile_WriteUpdate (CIRCFILE *c, void *record);
*	int circfile_AcknowledgeRecord (CIRCFILE *c, const int record_no);
*	int circfile_LookVarLength (CIRCFILE *c, void *record,
*				const int maxlength, const int record_no);
*	int circfile_ReadVarLength (CIRCFILE *c, void *record, 
*						const int maxlength);
*	int circfile_WriteVarLength (CIRCFILE *c, void *record, 
*					const int reclength);
*	int circfile_AckVarLength (CIRCFILE *c, const int record_no,
*							const int reclength);
*	int circfile_RefreshPointers (CIRCFILE *c);
*	
*	int circfile_qCorrectN (CIRCFILE *c, int n);
*	int circfile_qLrnr (CIRCFILE *c);	i.e. query last-recordno-read
*	int circfile_qLrnw (CIRCFILE *c);	i.e. query last-recordno-written
*	int circfile_qNtbr (CIRCFILE *c);	i.e. query next-to-be-read
*	int circfile_qNtbw (CIRCFILE *c);	i.e. query next-to-be-written
*	int circfile_qNtbwLess1  (CIRCFILE *c);	i.e. query next-to-be-written-1
*	int circfile_qNnotRead   (CIRCFILE *c);	i.e. query nrecords not read
*	int circfile_qNavailable (CIRCFILE *c);	i.e. query nrecords to be read
*	int circfile_qMaxRecords (CIRCFILE *c);	i.e. query maximum record
*	int circfile_qRecordsPerFile (CIRCFILE *c); i.e. query records per file
*	int circfile_qRecordSize (CIRCFILE *c);	i.e. query record size
*	int circfile_CorrectRecordNo   (CIRCFILE *c, int record_no);
*	int circfile_IncrementRecordNo (CIRCFILE *c, int *record_no);
*	int circfile_DecrementRecordNo (CIRCFILE *c, int *record_no);
*	
*	int circfile_SetDebugMode (CIRCFILE *c, const int i);
*
* PARAMETERS:
*		CIRCFILE *c	(in/out) structure holding circfile details.
*					(calling sequences use:  &circfile)
*		char *homedir	(in)	pointer to a static string, the home
*					directory to be used for the next open.
*		char *prefix	(in)	1-20 name to be used in the
*					file names  prefix.dat,  prefix.ptr
*		int  yesno	(in)	0 = no, 1 = yes.
*               int  max_records(in)	the file holds this many records
*		int  record_size(in)	each record is this long (in bytes)
*		void *record	(in/out) one data record
*		void *record_recno (in) integer within data record that will
*					hold record number.
*		int  record_no	(in)	specific record number in the file
*		int  records_per_file (in) for multi-data-files.
*
* RETURN VALUE	0 = success,
*		-2 = (for ReadUpdate only)  no data to be read.
*		-2 = (for Increment/Decrement only)  at start/end-of-file.
*		-2 = (for OpenWriter/WriteUpdate only)  failed, file is full.
*		-2 = (for AcknowledgeRecord only)  failed, this record is not
*						the ntbr record number.
*		-1 = error, TRACE messages have been logged
*			(or saved for the caller to retrieve it later
*			 with TRACE_PREVIOUS)
*
*		This toolkit uses the (CMSS) log conventions to write
*		error messages (generated by TRACE) to a logfile.
*		See external "logc" and "tracec" routines for details.
*		
* DESCRIPTION	This is a toolkit of subroutines for reading and writing
*		circular files containing fixed length records.
*
*		The data records are stored on a file called "yourname.dat"
*		and the pointers on file "yourname.ptr". Pointers are:
*		Ntbw (next to be written), Ntbr (next to be read),
*		MaxRecords  (records in file),  RecordSize  (bytes/record).
*
*		The files are interlocked (using f-lock) so that multiple
*		readers and/or writers can safely update the file any time.
*
*		Circular files are automatically 'prezero'ed to reserve space
*		to get fast disk accesses.
*
*		Full details of all cirfile operations and conventions are
*		given below in "Usage".
*
* WARNINGS	If an error occurs within CIRCFILE, an explanatory traceback
*		message is put onto the CMSS log file. The messages look like:
*			myfile xxxx failed: (system errno text)
*		(where xxxx is open,read,write,seek,etc).
*		The caller could possibly follow this up with their own Alarm
*		e.g.   "myfile failure. See Log file."
*
*		(Traceback error messages can be saved instead of logged,
*		 see below).
*
*		When new files are created, existing files are lost.
*
* USAGE		There are various "roles" of users:
*		"Writers"  write data and update the Ntbw pointer.
*		"Readers"  read data and update the Ntbr pointer.
*		"Lookers"  only read the data and read the pointers.
*			   (Lookers are programs like operator displays)
*
*		Normally these circular files have one data file. (<2Gb).
*		However there is an option to use multiple data files
*		to store more than 2Gb total data.
*
*		Note: Below is an Ansi-C perspective.
*		      For C++, see 'cirfile.h' for CIRFILE object definitions.
*
*		(0) All users must declare a circular file object by:
*			CIRCFILE  myfile;
*		    and must initialise it by:
*			circfile_Init (&myfile);
*		    and close it later by:
*			circfile_Close (&myfile);
*
*		(0b) If you want to access circular files in other than the
*		    current directory, you must precede all Open or Create calls
*		    with a call to set up the home directory of the files.
*		    e.g.   circfile_SetDirectory (&myfile,"/home/fred/files")
*		    Note that after the files are closed (after Close, or a bad
*		    Open) the directory is reset to the current dir.
*
*		(1) The circular files are assumed to exist. So the system
*		    manager must specifically create them using a small main
*		    program calling "circfile_Create(...)".
*		    (e.g. see programs cre8logc, createdir (for Cmss dirs))
*
*		    For multiple-data-files, call "circfile_CreateMultiFile(...)"
*
*		(1b) When data files are created, they are always pre-filled with
*		     zero data, to reserve the required amount of disk. (See 1d).
*
*		(1c) Circular files can be expanded at any time, and the extra
*		     space is prefilled with zeros. (See 1d).
*		     Call "ResetMaxRecords (...)", or preferably use the
*		     utiltiy program 'resetmaxrecords'.
*
*		(1d) Programs reading data files should expect to handle records
*		     containing only zeros, and look elsewhere in the file for 
*		     real data records.
*
*		(2) "Writers" must open the files with:
*				circfile_OpenWriter (&myfile,filename)
*		     and then write their data using
*				circfile_WriteUpdate (&myfile,record)
*
*		(3) "Readers" must open the files with:
*				circfile_OpenReader (&myfile,filename)
*		     and then read their data using
*				circfile_ReadUpdate (&myfile,record)
*
*		(4) "Lookers" must open the files with:
*				circfile_OpenLooker (&myfile,filename)
*		     then get the latest pointers by:
*				circfile_RefreshPointers(&myfile)
*				ntbr = circfile_qNtbr(&myfile)
*				..etc ntbw, maxrecords, etc
*		     and then read specific records of data using
*				circfile_LookRecord (&myfile,record,recordno)
*
*		     "Lookers" should call IncrementRecordNo/DecrementRecordNo
*		     to safely do forward/backward recordno calculations,
*		     in case the circular file is expanded online.
*		     "Backward Searches" can be started with recordno=-1,
*		     and a suitable recordno will be returned.
*
*		(5) The query operations qLrnr and qLrnw will reply the record
*		    number of the last record number read or written by this
*		    program.
*		    (This is only valid after successful reads/writes).
*		    These record numbers may be useful for e.g. imbedding in
*		    error messages. They can also be used for cross-references
*		    and can be stored on other circular file records by
*		    	circfile_RewriteRecord 
*
*		(6) The query operations qNtbr, qNtbw will reply the next-to-be-
*		    read or written (record number) pointers as they were after
*		    the last read/write/refresh operation. These pointers are
*		    NOT necesarily the the most up-to-date values on the file
*		    itself (since further operations may have been done on it
*		    by other users).
*		    Remember to use the RefreshPointers() operation to get the
*		    up-to-date values.
*
*		(7) Any users who want to suppress logging of trace messages
*		    issued from CIRCFILE, should use
*			circfile_SaveTraceMessages (&myfile,1)
*		    before opening the cirfile.  The messages can be retrieved
*		    later by TRACE_PREVIOUS (1) if required.
*
*		(8) AcknowledgeRecord and DiscardUnreadRecords are two
*		    operations that are included for managing files of alarm
*		    messages where individual alarms need to be acknowledged
*		    or excess alarms need to be discarded.
*
*		(9) SetStoreRecordno is a special call to set up a mode where
*		    the record number of each record written is stored within
*		    the record itself before it is written.
*		    You can invoke this mode just after you have opened a
*		    file for Writing, by doing a single call as follows:
*		    circfile_SetStoreRecordno (&myfile,&record, &record.recno)
*		    where "recno" is the integer within the record structure
*		    that will hold its own record number.
*		    (N.B. this call just saves the address of "recno". The
*			actual record numbers are stored during Write calls.)
*
*		(10) RewriteRecord is an operation available to update the
*		     contents of records some time after the record was first 
*		     written. Use Qlrnw to find out the record number.
*		     (The file must be opened for writes).
*
*		(11) SetSyncWrites can be used to vary the disk-write properties.
*		     By default all disk-writes are "sync"ed, i.e. the data is
*		     fully written to disk. This is very safe but can be slow
*		     for high frequency writes. Hence high-frequency but 
*		     relatively unimportant files (e.g. journals) can be set
*		     to "nosync" to speed up the program. However, if the
*		     Unix system crashes, expect to lose data and maybe 
*		     corrupt the pointer file.
*		     If you set environment variable CIRCFILENOSYNC, then the
*		     default for all circular files is "nosysnc".
*		     This is used (by CMSS) when an external program is doing
*		     file-syncing on behalf of this program.
*
* SEE ALSO	logc, alarmc, trace
*
* HISTORY	$Header: /home/commsa/cmdv/cmss/src/RCS/circfile.c,v 1.16 2002/06/14 06:02:54 ace Exp $
*
*		v1.16 2002-06-14 ACE, fix pre-zero logic.
*		v1.15 2002-05-31 ACE, multiple-data-files.
*		v1.14 010108 ACE, refresh pointers in look-record.
*		v1.13 001123 ACE, refresh pointers in rewrite-record.
*		v1.12 001120 ACE, restore qNtbw (after accidental deletion).
*		v1.11 001116 ACE, spelling change qNtbwMinus1 (not qNtbwLess1)
*		v1.10 001116 ACE, added qNtbwLess1, IncrementMyNtbr.
*		v1.9  001115 ACE, added IncrementRecordNo,DecrementRecordNo,
*				  altered qCorrectN in preparation for file
*				  expansion later. Updated ResetMaxRecords.
*		v1.8  980513 ACE, added ResetMaxRecords.
*		v1.7  950407 ACE, fixed 'const' in calling sequences.
*		v1.6  950324 ACE, fixed documentation.
*		v1.5  941031 ACE, added RewriteRecord. Cleaned up comments.
*		v1.4  940218 ACE, fix bug in reset-ntbr/ntbw.
*		v1.2  940208 ACE, allow environment variable CIRCFILENOSYNC
*				  to disable default synching.
*		v1.0b 931222 ACE, selective locking of reads or writes,
*				  updates only read or write pointer.
*				  Dfeaults: yes-sync, yes-locking.
*		v1.0a 931025 ACE, converted to Ansi C for portability,
*				  from C++ cirfile, v1.12 930825.
*
**************************************************************************/

/***************************************************
**
**  PROGRAMMERS BEWARE:
**
**  Within this CIRCFILE source code, if ever you are writing new code to
**  generate new TRACE messages,
**  always do this pair of lines:
**
**		if (c->Save_messages) TRACE_SAVE_NEXT (1);
**		TRACE_...etc. (...your trace message);
**
**  This is because the Log system uses Cirfile, and an error on the logfile
**   (notified by CIRCFILE) has to be prevented from being reported to the
**   logfile (causing an infinite recursion).
****************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>
#ifdef TurboC
#include <io.h>
#else
#include <sys/file.h>
#include <unistd.h>
#endif
#include <string.h>
#include "circfile.h"
typedef CIRCFILE *C;
#include "circfint.h"
#include "tracec.h"

#define OK   0

/* Internal functions */
static int NotInit (C c);
static void Zero (C c);	/* to zero-out all variables. */
static int internal_BumpRecordNo (CIRCFILE *c, int *record_no, int how);

/*------------------ */
/* MAIN CODE FOLLOWS */
/*------------------ */

/**
* -----------------------------------------------------------------------------
*									Init
* -----------------------------------------------------------------------------
* Initialises all simple variables for a newly constructed object.
* Note that we force any real work (e.g. opening files)
* to be done in other routines that the user calls later,
* so that sensible error codes can be returned then.
*/
int circfile_Init (CIRCFILE *c) {

    /* zero-out all variables. */
    Zero(c);

    /* (Cannot use Debug flag until after Zero has been called ! ). */
    if (c->Debug) printf (" Initialising a CIRCFILE structure.\n");

    /* Mark the structure as active and initialised. (See NotInit).*/
    c->Magic = CIRCFILE_MAGIC;
    return (0);
}

/**
* -----------------------------------------------------------------------------
*									NotInit
* -----------------------------------------------------------------------------
* Externally callable access to NotInit.
*/
int circfile_NotInit (C c) {
    return (NotInit(c));
}

/**
* -----------------------------------------------------------------------------
*							(internal)	NotInit
* -----------------------------------------------------------------------------
* (Short name for function to aid readability within this source file)
* Test if a circular-file-structure has been initialised, and if not,
* to trace (log) an error message.
* Returns:  0 = OK, was initialised before.
*          -1 = Error, not initialised. Trace message generated.
*/
static int NotInit (C c) {
    if (c->Magic != CIRCFILE_MAGIC) {
	TRACE_SAVE_NEXT (1);
	return (TRACE (-1,"CIR010F CIRCFILE STRUCTURE NOT INITIALISED."));
    }
    return (0);
}

/**
* ---------------------------------------------------------------------------
*									Close
* ---------------------------------------------------------------------------
* Close the circular file (2 files), and reset structure to zero.
*/
int circfile_Close (CIRCFILE *c)
{
    /* Check that we have a correctly initialised structure */
    if (NotInit(c)) return (-1);

    if (c->Debug)
    printf (" Closing CIRCFILE: %s.\n",c->Prefix);

    /* Close the 2 files. */
    if (c->Dat_handle>=0) close (c->Dat_handle);
    if (c->Ptr_handle>=0) close (c->Ptr_handle);
    c->Dat_handle = -1;
    c->Ptr_handle = -1;

    /* and zero-out all other variables. */
    Zero(c);

    return (OK);
}

/**
* ---------------------------------------------------------------------------
*							(internal)	Zero
* ---------------------------------------------------------------------------
* This resets all the parameters back to a zero state.
* This is called from:  Init and Close.
* It leaves the "magic" value as is.
*/
static void Zero (C c) {
    static char dot[]=".";

    /* Initialises all simple variables. */
    c->Prefix[0] = '\0';	/* Used to name the 2 files: prefix.DAT, prefix.PTR */
    c->Max_records = 0;		/* maximum number of records in the file */
    c->Record_size = 0;		/* number of bytes in each fixed length record */
    c->Multiple_files = 0;	/* 0 = single, 1 = multiple data files. */
    c->Current_file_number = -1; /* 0...n, which of the multiple data files
				   is currently open.  -1 means nothing open.*/
    c->Cirfile_mode = CLOSED;	/* (see header file) */
    c->Dat_handle = -1;		/* file handle for  name.DAT file. */
    c->Ptr_handle = -1;		/* file handle for  name.PTR file. */
    c->Ntbr = 0;		/* next_to_be_read (a record number) */
    c->Ntbw = 0;		/* next_to_be_written (a record number) */
    c->Save_messages = 0;	/* 0 = dont save (but do log), 1 = do save, dont log. */
    c->Debug = 0; 		/* 0=noprints, 1=print debug msgs. */
    c->Lrnr = -1;		/* last record number read. */
    c->Lrnw = -1;		/* last record number written. */
    c->Home_dir = dot;		/* no special home directory. */
    c->Store_recno = 0;		/* do not store record numbers within data records. */
    c->Recno_index = 0;		/* no offset yet. */
    c->SyncWrites = 1;		/* 0=dont sync, 1=yes, sync writes.*/
    c->LockedReads = 0;		/* 0=nolock, 1=yes, lock read-updates.*/
    c->LockedWrites = 0;	/* 0=nolock, 1=yes, lock write-updates.*/
    /* do not touch the "magic" value. */

    /* Allow environment variable to disable write-syncs.*/
    if (getenv("CIRCFILENOSYNC") != NULL)  c->SyncWrites = 0;  /* 0=dont sync */
}

/**
* ---------------------------------------------------------------------------
*						(query functions)    qXxxxx
* ---------------------------------------------------------------------------
* Simple functions to Query values.
*
* Theoretically these 'query' functions have no side-effects.
*
* However, in this package, we now allow the file to expand online.
* Which means that sometimes the values have to be re-read from the file,
* just in case they were changed by another process.
*
* So some of these 'query' routines do have the small and safe side-effect
* of doing a file-read.
*
* Returns:  >=0 = success, value returned.
*	    -1  = failed, not initialised.
*/
int circfile_qLrnr (CIRCFILE *c) {
    if (NotInit(c)) return (-1);   return c->Lrnr; }

int circfile_qLrnw (CIRCFILE *c) {
    if (NotInit(c)) return (-1);   return c->Lrnw; }

int circfile_qNtbr (CIRCFILE *c) {
    if (NotInit(c)) return (-1);   return c->Ntbr; }

int circfile_qNtbw (CIRCFILE *c) {
    if (NotInit(c)) return (-1);   return c->Ntbw; }

int circfile_qRecordSize (CIRCFILE *c) {
    if (NotInit(c)) return (-1);   return c->Record_size; }

int circfile_qMaxRecords (CIRCFILE *c) {
    if (NotInit(c)) return (-1);   return c->Max_records; }

int circfile_qRecordsPerFile (CIRCFILE *c) {
    if (NotInit(c)) return (-1);   return c->Records_per_file; }

int circfile_qNtbwMinus1 (CIRCFILE *c) {
    if (NotInit(c)) return (-1);
    return (circfile_qCorrectN (c, c->Ntbw - 1 ));
}

/** CORRECT -- Compute the correct record number,
*		wrapping around within the circular file.
*	Note: it re-reads pointers before wrapping around.
*/
int circfile_qCorrectN (CIRCFILE *c, int n) {
    int n2, reply;
    if (NotInit(c)) return (-1);
    if (c->Max_records == 0)  return (-1);
    
    if ((n >= 0) && (n < c->Max_records))  return (n);
    
    /* Just in case Maxrecords has increased recently, */
    /* recheck the pointers.*/
    reply = circfint_ReadPtrs (c);
    if (reply)  return (-1);	/* -1, hard error */
    
    n2 = n % c->Max_records;
    if (n2 < 0)  n2 += c->Max_records;
    return (n2);
}

int circfile_qNnotRead (CIRCFILE *c) {
    int n, reply;
    if (NotInit(c)) return (-1);

    n = c->Ntbw - c-> Ntbr;

    /* Just in case Maxrecords has increased recently, */
    /* recheck the pointers.*/
    reply = circfint_ReadPtrs (c);
    if (reply)  return (-1);	/* -1, hard error */
    
    if (c->Ntbw < c-> Ntbr) n += c->Max_records;
    return (n);
}

int circfile_qNavailable (CIRCFILE *c) {
    int unread, n, reply;
    if (NotInit(c)) return (-1);

    /* Just in case Maxrecords has increased recently, */
    /* recheck the pointers.*/
    reply = circfint_ReadPtrs (c);
    if (reply)  return (-1);	/* -1, hard error */

    unread = c->Ntbw - c-> Ntbr;
    if (c->Ntbw < c-> Ntbr) unread += c->Max_records;
    
    n = c->Max_records-1 - unread;
    return (n);
}

/**
* ---------------------------------------------------------------------------
*							SaveTraceMessages
* ---------------------------------------------------------------------------
* The logfile needs to set SaveTraceMessage ON to avoid recursively
* logging errors.
*/
int circfile_SaveTraceMessages (CIRCFILE *c, const int yesno) {

    /* Check that we have a correctly initialised structure */
    if (NotInit(c)) return (-1);

    if (c->Debug) printf (" Set SaveTraceMessages CIRCFILE: %s.\n",c->Prefix);

    c->Save_messages = yesno;
    return (OK);
}

/**
* ---------------------------------------------------------------------------
*								SetDebugMode
* ---------------------------------------------------------------------------
* To set/unset debug mode.
* When debug mode is set, commentary printouts are given. 
*/
int circfile_SetDebugMode (CIRCFILE *c, const int yesno) {
    if (NotInit(c)) return (-1);
    c->Debug = yesno;
    return (OK);
}

/**
* ---------------------------------------------------------------------------
*								SetSyncWrites
* ---------------------------------------------------------------------------
* On UNIX, maybe make writes go straight to disk.
* (avoids losing data in a crash when cache is lost).
* Recommended for all but high-volume log files.
*/
int circfile_SetSyncWrites (CIRCFILE *c, const int yesno) {
    if (NotInit(c)) return (-1);
    c->SyncWrites = yesno;
    return (OK);
}

/**
* ---------------------------------------------------------------------------
*								SetDirectory
* ---------------------------------------------------------------------------
* Set the file directory for the next open operation.
* Returns: 0=OK, n = error (and a saved Trace message is stored)
*/
int circfile_SetDirectory (CIRCFILE *c, const char *homedir) {

    /* Check that we have a correctly initialised structure */
    if (NotInit(c)) return (-1);

    if (c->Debug) printf (" SetDirectory CIRCFILE: %s.\n",c->Prefix);

    c->Home_dir = (char *)homedir;
    return (OK);
}

/**
* ---------------------------------------------------------------------------
*							       SetToMultiFile
* ---------------------------------------------------------------------------
* Resets an open single-data-file to a multi-data-file of one file.
*
* WARNING: This should only be done when the files are NOT BEING USED.
*	STOP your application programs before making this change.
*	Although we reset the pointers file very safely,
*	and although all readers and writers who use locking will pick up the
*	new values correctly,
*	there are other unlocked applications (e.g. 'read-only' jobs)
*	which may not see the new pointers and may run incorrectly. 
*
* Returns: 0=OK, n = error (and a saved Trace message is stored)
*/
int circfile_SetToMultiFile (CIRCFILE *c, const int records_per_file)
{
    int reply;

    /* Check that we have a correctly initialised structure */
    if (NotInit(c)) return (-1);

    if (c->Debug) printf (" Setting To Multi-file: %s.\n",c->Prefix);

    if (c->Cirfile_mode!=WRITER) {
        if (c->Save_messages) TRACE_SAVE_NEXT (1);
	TRACE_CHARS (-1,"CIR003F NOT OPEN FOR Write: ",c->Prefix);
        return (-1);
    }

    /* Get up-to-date pointers. */
    reply = circfint_ReadPtrs (c);
    if (reply) return (-1);

    if (c->Multiple_files != 0) {
        if (c->Save_messages) TRACE_SAVE_NEXT (1);
	TRACE_CHARS (-1,"CIR00?F IS ALREADY A MULTI-FILE: ",c->Prefix);
        return (-1);
    }
    
    if (records_per_file < c->Max_records) {
        if (c->Save_messages) TRACE_SAVE_NEXT (1);
	TRACE_CHARS (-1,"CIR00?F RECORDS-PER-FILE TOO SMALL: ",c->Prefix);
        return (-1);
    }

    /* Change pinters to be Multi-file.*/
    c->Records_per_file = records_per_file;
    c->Multiple_files = 1;

    /* Update the pointers file */
    reply = circfint_WritePtrs (c, ALL_PTRS);
    if (reply) return (-1);

    return (OK);
}

/**
* ---------------------------------------------------------------------------
*				(single data file)	Create (new files)
* ---------------------------------------------------------------------------
* Create a new circular file, store its size, etc, then close it.
* i.e. it creates files  *.DAT (empty)  and *.PTR (initialised pointers).
* Returns: 0=OK, n = error (and a saved Trace message is stored)
*/
int circfile_Create (CIRCFILE *c,
		const char *prefix, const int max_records, 
		const int record_size) {

return ( circfile_CreateMultiFile (c, prefix, max_records, record_size, 0));
}
/**
* ---------------------------------------------------------------------------
*			(multiple data files)	CreateMultiFile (new files)
* ---------------------------------------------------------------------------
* Create a new circular file, with multiple *.DAT files,
* store its size, etc, then close it.
* i.e. it creates files  *.DAT (empty)  and *.PTR (initialised pointers).
* Returns: 0=OK, n = error (and a saved Trace message is stored)
*/
int circfile_CreateMultiFile (CIRCFILE *c,
		const char *prefix, const int max_records, 
		const int record_size, const int records_per_file) {
   int error;

    /* Check that we have a correctly initialised structure */
    if (NotInit(c)) return (-1);

    if (c->Debug) printf (" Creating CIRCFILE: %s.\n",prefix);

    /* Validate filename. */
    error = circfint_ValidateFilename (c, prefix);
    if (error)  return(error);

    /* Must have at least 2 records in the file, */
    /* because we only store up to n-1 records in it.*/

    /* Store and validate the pointer parameters. */
    c->Max_records = max_records;
    c->Record_size = record_size;
    c->Records_per_file = records_per_file;
    c->Ntbr = 0;		/* next_to_be_read (a record number) */
    c->Ntbw = 0;		/* next_to_be_written (a record number)*/
    if (records_per_file > 0) { c->Multiple_files = 1; }
    error = circfint_ValidatePtrs (c);
    if (error)  { circfile_Close (c); return (error); }

    /* Now start new files. */
    /* All parameters look OK, now create the files. */
    c->Cirfile_mode = CREATE;
    error = circfint_OpenFiles (c);

    /* (if there was an error, a trace message was given and the object Closed) */
    if (error)   return (error);

    /* Close the files. */
    circfile_Close(c);

    return (OK);
}

/**
* ---------------------------------------------------------------------------
*								OpenReader 
* ---------------------------------------------------------------------------
* Open a circular file for a reader (and updater).
* Returns: 0=OK, n = error (and a saved Trace message is stored)
*/
int circfile_OpenReader (CIRCFILE *c, const char *prefix) {

    int error;

    /* Check that we have a correctly initialised structure */
    if (NotInit(c)) return (-1);

    if (c->Debug) printf (" OpenReader CIRCFILE: %s.\n",prefix);

    /* Open both files. (with *.DAT in Read-only mode). */
    error = circfint_OpenValidate (c, prefix, READER);

    /* The above also Reads the current pointers from the file, */
    /* and does a validation check. */
    /* If there was an error, the trace_msg was saved. */

    return (error);
}

/**
* ---------------------------------------------------------------------------
*								OpenWriter 
* ---------------------------------------------------------------------------
* Open a circular file for writer (and updater)
* Returns: 0=OK, n = error (and a saved Trace message is stored)
*/
int circfile_OpenWriter (CIRCFILE *c, const char *prefix) {

    int error;

    /* Check that we have a correctly initialised structure */
    if (NotInit(c)) return (-1);

    if (c->Debug) printf (" OpenWriter CIRCFILE: %s.\n",prefix);

    /* Open both files. (with *.DAT in Write&read mode). */
    error = circfint_OpenValidate (c, prefix, WRITER);

    /* The above also Reads the current pointers from the file, */
    /* and does a validation check. */
    /* If there was an error, the trace_msg was saved. */

    return (error);
}

/**
* ---------------------------------------------------------------------------
*								OpenWriteOnly 
* ---------------------------------------------------------------------------
* Open a circular file for a writer of a file
*  which will never have a reader-updater.  (only a Looker) 
*  (e.g. a log file that can overwrite itself)
* Returns: 0=OK, n = error (and a saved Trace message is stored)
*/
int circfile_OpenWriteOnly (CIRCFILE *c, const char *prefix) {

    int error;

    /* Check that we have a correctly initialised structure */
    if (NotInit(c)) return (-1);

    if (c->Debug) printf (" OpenWriteOnly CIRCFILE: %s.\n",prefix);

    /* Open both files. (with *.DAT in Write&read mode). */
    error = circfint_OpenValidate (c, prefix, WRITEONLY);

    /* The above also Reads the current pointers from the file, */
    /* and does a validation check. */
    /* If there was an error, the trace_msg was saved. */

    return (error);
}

/**
* ---------------------------------------------------------------------------
*								OpenLooker
* ---------------------------------------------------------------------------
* Open a circular file for a Looker (reads but never updates).
* Returns: 0=OK, n = error (and a saved Trace message is stored)
*/
int circfile_OpenLooker (CIRCFILE *c, const char *prefix) {

    int error;

    /* Check that we have a correctly initialised structure */
    if (NotInit(c)) return (-1);

    if (c->Debug) printf (" OpenLooker CIRCFILE: %s.\n",prefix);

    /* Open both files in Read-only mode. */
    error = circfint_OpenValidate (c, prefix, LOOKER);

    /* The above also Reads the current pointers from the file, */
    /* and does a validation check. */
    /* If there was an error, the trace_msg was saved. */

    return (error);
}

/**
* ---------------------------------------------------------------------------
*							SetUnlockedReads
* ---------------------------------------------------------------------------
* After the file has been opened, a call to this routine will disable
* interlocking of ReadUpdate operations.
* This only makes sense when there is only ever 1 reader program.
* This unlocked mode is safer for NFS-mounted remote files.
* Returns:  0 = success,
*	   -1 = error, structure not initialised.
*/
int circfile_SetUnlockedReads (CIRCFILE *c) {

    /* Check that we have a correctly initialised structure */
    if (NotInit(c)) return (-1);

    if (c->Debug) printf (" Set UnlockedReads on CIRCFILE: %s.\n",c->Prefix);

    c->LockedReads = 0;
    return (OK);
}

/**
* ---------------------------------------------------------------------------
*							SetUnlockedWrites
* ---------------------------------------------------------------------------
* After the file has been opened, a call to this routine will disable
* interlocking of WriteUpdate & WriteOnly operations.
* This only makes sense when there is only ever 1 writer program.
* This unlocked mode is safer for NFS-mounted remote files.
* Returns:  0 = success,
*	   -1 = error, structure not initialised.
*/
int circfile_SetUnlockedWrites (CIRCFILE *c) {

    /* Check that we have a correctly initialised structure */
    if (NotInit(c)) return (-1);

    if (c->Debug) printf (" Set UnlockedWrites on CIRCFILE: %s.\n",c->Prefix);

    c->LockedWrites = 0;
    return (OK);
}

/**
* ---------------------------------------------------------------------------
*							SetStoreRecordno
* ---------------------------------------------------------------------------
* Set the file into a "StoreRecordno" mode so that in the future, when 
* user data records are about to be written, the record number will be 
* stored in a specified integer within the record, and then the record will 
* be written to the file. 
* This option is used in CMSS to remember original record numbers of 
* original data records, even after records have been copied and changed 
* by later processes. 
* N.B. The circular file must be already open as a writer (and updater) 
* Returns: 0 = OK, 
*	  -n = error (and a saved Trace message is stored)
*/

int circfile_SetStoreRecordno (CIRCFILE *c, void *record, void *record_recno) {

    int *p1, *p2;

    /* Check that we have a correctly initialised structure */
    if (NotInit(c)) return (-1);

    if (c->Debug) printf (" SetStoreRecordno on CIRCFILE: %s.\n",c->Prefix);

    /* Only discard the records if the request is valid. */
    if (c->Cirfile_mode==CLOSED) {
        if (c->Save_messages) TRACE_SAVE_NEXT (1);
	return (TRACE (-1,"CIR004F FILE NOT OPEN YET."));
    }
    if ( (c->Cirfile_mode!=WRITER) && (c->Cirfile_mode!=WRITEONLY) ) {
        if (c->Save_messages) TRACE_SAVE_NEXT (1);
	return (TRACE_CHARS(-1,"CIR002F NOT OPEN FOR Write ON: ",c->Prefix));
    }

    p1 = (int *)record;
    p2 = (int *)record_recno;
    /* Note: because the compiler knows that it is subtracting pointers to */
    /* integers, it automatically adjusts for the size of each integer */
    /* and so "index" accurately points to the required integer array index. */
    c->Recno_index = p2 - p1;
    c->Store_recno = 1;   /* Yes, do store record numbers. */
    return (OK);
}

/**
* ---------------------------------------------------------------------------
*							DiscardUnreadRecords
* ---------------------------------------------------------------------------
* Discard all unread records by pretending to have read them all. 
* i.e. alter the read-pointer to be equal to the write-pointer. 
* N.B. The circular file must be already open as a reader (and updater)
* Returns: 0 = OK, 
*	  -n = error (and a saved Trace message is stored)
*/
int circfile_DiscardUnreadRecords (CIRCFILE *c) {

    int myreply, reply, reply2;

    /* Check that we have a correctly initialised structure */
    if (NotInit(c)) return (-1);

    if (c->Debug) printf (" DiscardUnreadRecords on CIRCFILE: %s.\n",c->Prefix);

    /* Only discard the records if the request is valid. */
    if (c->Cirfile_mode==CLOSED) {
        if (c->Save_messages) TRACE_SAVE_NEXT (1);
	return (TRACE (-1,"CIR004F FILE NOT OPEN YET."));
    }
    if (c->Cirfile_mode!=READER) {
        if (c->Save_messages) TRACE_SAVE_NEXT (1);
	return (TRACE_CHARS(-1,"CIR002F NOT OPEN FOR ReadUpdate ON: ",c->Prefix));
    }

    /* Now change the read-pointer to equal the write-pointer. */

    /* Lock the file while we read it.  Always unlock it afterwards. */

    myreply = -1;  /* Default is Error. */
    for (;;) {   /* dummy loop so we can exit on errors */

	if (c->LockedReads) {
	    reply = circfint_Lock (c, READ_PTR);
	    if (reply)  break;
	}

	/* Get up-to-date pointers. */
	reply = circfint_ReadPtrs (c);
	if (reply)  break;

	if (c->Ntbr!=c->Ntbw)  {  /* There is some unread data */
	    /* Move the next-to-be-read pointer to the next (un-read) record. */
	    c->Ntbr = c->Ntbw;

	    /* Update the file */
	    reply = circfint_WritePtrs (c, READ_PTR);
	    if (reply)  break;
	}
	myreply = OK;  /* Success */
	break;
    }

    /* Always unlock the file (regardless of above errors) */
    if (c->LockedReads) reply2 = circfint_Unlock (c, READ_PTR);
    else		reply2 = 0;
    if (reply)    return (reply);  /* First error seen */
    if (reply2)   return (reply2); /* Unlock error */

    return (myreply);
}

/**
* ---------------------------------------------------------------------------
*								ResetNtbr
* ---------------------------------------------------------------------------
* Reset the ntbr pointer.
* (This is useful to re-read input data after recovering from a system crash.)
* N.B. The circular file must be already open as a reader/writer (and updater)
* Returns: 0 = OK, 
*	  -n = error (and a saved Trace message is stored)
*/
int circfile_ResetNtbr (CIRCFILE *c, const int ntbr) {

    int myreply, reply, reply2;

    /* Check that we have a correctly initialised structure */
    if (NotInit(c)) return (-1);

    if (c->Debug) printf (" ResetNtbr on CIRCFILE: %s.\n",c->Prefix);

    /* Only reset if the request is valid. */
    if (c->Cirfile_mode==CLOSED) {
        if (c->Save_messages) TRACE_SAVE_NEXT (1);
	return (TRACE (-1,"CIR004F FILE NOT OPEN YET."));
    }
    if ((c->Cirfile_mode!=READER) && (c->Cirfile_mode!=WRITER)) {
        if (c->Save_messages) TRACE_SAVE_NEXT (1);
	return (TRACE_CHARS(-1,"CIR002F NOT OPEN FOR Update ON: ",c->Prefix));
    }

    /* Now change the read-pointer. */
    /* (The pointer will automatically be validated by WritePtrs.) */

    /* Lock the file while we read it.  Always unlock it afterwards. */

    myreply = -1;  /* Default is Error. */
    for (;;) {   /* dummy loop so we can exit on errors */

	if (c->LockedReads) {
	    reply = circfint_Lock (c, READ_PTR);
	    if (reply)  break;
	}

	/* Get up-to-date pointers. */
	reply = circfint_ReadPtrs (c);
	if (reply)  break;

	/* Move the next-to-be-read pointer. */
	c->Ntbr = ntbr;

	/* Update the file */
	reply = circfint_WritePtrs (c, READ_PTR);
	if (reply)  break;
	
	myreply = OK;  /* Success */
	break;
    }

    /* Always unlock the file (regardless of above errors) */
    if (c->LockedReads) reply2 = circfint_Unlock (c, READ_PTR);
    else		reply2 = 0;
    if (reply)    return (reply);  /* First error seen */
    if (reply2)   return (reply2); /* Unlock error */

    return (myreply);
}

/**
* ---------------------------------------------------------------------------
*								ResetNtbw
* ---------------------------------------------------------------------------
* Reset the ntbw pointer.
* (This is useful to re-write input data after recovering from a system crash.)
* N.B. The circular file must be already open as a reader/writer (and updater)
* Returns: 0 = OK, 
*	  -n = error (and a saved Trace message is stored)
*/
int circfile_ResetNtbw (CIRCFILE *c, const int ntbw) {

    int myreply, reply, reply2;

    /* Check that we have a correctly initialised structure */
    if (NotInit(c)) return (-1);

    if (c->Debug) printf (" ResetNtbw on CIRCFILE: %s.\n",c->Prefix);

    /* Only reset if the request is valid. */
    if (c->Cirfile_mode==CLOSED) {
        if (c->Save_messages) TRACE_SAVE_NEXT (1);
	return (TRACE (-1,"CIR004F FILE NOT OPEN YET."));
    }
    if ((c->Cirfile_mode!=READER) && (c->Cirfile_mode!=WRITER)) {
        if (c->Save_messages) TRACE_SAVE_NEXT (1);
	return (TRACE_CHARS(-1,"CIR002F NOT OPEN FOR Update ON: ",c->Prefix));
    }

    /* Now change the write-pointer. */
    /* (The pointer will automatically be validated by WritePtrs.) */

    /* Lock the file while we read it.  Always unlock it afterwards. */

    myreply = -1;  /* Default is Error. */
    for (;;) {   /* dummy loop so we can exit on errors */

	if (c->LockedWrites) {
	    reply = circfint_Lock (c, WRITE_PTR);
	    if (reply)  break;
	}

	/* Get up-to-date pointers. */
	reply = circfint_ReadPtrs (c);
	if (reply)  break;

	/* Move the next-to-be-read pointer. */
	c->Ntbw = ntbw;

	/* Update the file */
	reply = circfint_WritePtrs (c, WRITE_PTR);
	if (reply)  break;
	
	myreply = OK;  /* Success */
	break;
    }

    /* Always unlock the file (regardless of above errors) */
    if (c->LockedWrites) reply2 = circfint_Unlock (c, WRITE_PTR);
    else		reply2 = 0;
    if (reply)    return (reply);  /* First error seen */
    if (reply2)   return (reply2); /* Unlock error */

    return (myreply);
}

/**
* ---------------------------------------------------------------------------
*                                                            ResetMaxRecords
* ---------------------------------------------------------------------------
* Reset the Max_records counter. (File must be open as a Writer).
*
* WARNING: This should only be done when the files are NOT BEING USED.
*	STOP your application programs before making this change.
*	Although we reset the pointers file very safely,
*	and although all readers and writers who use locking will pick up the
*	new values correctly,
*	there are other unlocked applications (e.g. 'read-only' jobs)
*	which may not see the new pointers and may run incorrectly. 
*	Also some applications may use MAX_RECORDS via a local variable
*	which is never refreshed. 
*
* ResetMaxRecords useful to expand/contract the circular file size
* while preserving existing data.
* In reality, there are lots of problems in shrinking files online.
* So here we mainly cater for expansion online.
* N.B. The circular file must be already open as a reader/writer (and updater)
* N.B. Fails if there are un-read records spanning the end of the file.
* N.B. Fails if NTBW is beyond the end of the file.
* N.B. Expect zeros (nulls) to be displayed if you run the circfile print
*	utilities beyond the old eof.
* Returns: 0 = OK,
*         -n = error (and a saved Trace message is stored)
*/
int circfile_ResetMaxRecords (CIRCFILE *c, const int newmax) {

    int oldmax, myreply, reply, reply2;

    /* Check that we have a correctly initialised structure */
    if (NotInit(c)) return (-1);
    if (c->Debug) printf (" ResetMaxRecords on CIRCFILE: %s.\n",c->Prefix);

    /* Only reset if the request is valid. */
    if (c->Cirfile_mode==CLOSED) {
        if (c->Save_messages) TRACE_SAVE_NEXT (1);
        return (TRACE (-1,"CIR004F FILE NOT OPEN YET."));
    }
    /* Must be a Writer, so we can write the zero-fill.*/
    if (c->Cirfile_mode!=WRITER) {
        if (c->Save_messages) TRACE_SAVE_NEXT (1);
        return (TRACE_CHARS(-1,"CIR002F NOT OPEN FOR Write ON: ",c->Prefix));
    }

    /* We will pre-zero-fill all extra new space at the end of the file.*/
    /* This may take some time on a large file, so do it without file-locking.*/
    /* Do a quick pre-check, then assume it is OK. It gets rechecked later.*/
    if (newmax > c->Max_records) {
        /* Check that no un-read records overlap the end of the file. */
        if ( c->Ntbw < c->Ntbr ) {
            /* Woops. Do not disturb unread records. */
            if (c->Save_messages) TRACE_SAVE_NEXT (1);
            reply = TRACE (-2,"CIR011F CANNOT RESET MAX_RECORDS. NTBW<NTBR.");
            return (reply);
        }

	/* Store the newmax now, because it is used within PreZero routines.*/
	oldmax = c->Max_records;
        c->Max_records = newmax;

	if (c->Multiple_files) {
	    /* Need to pad out each *.dat file in turn.*/
	    reply = circfint_PreZeroFiles (c, oldmax);
	    if (reply) return (reply);
	}
	else {              
	    reply = circfint_PreZeroRecords (c, oldmax, newmax);
	    if (reply) return (reply);
	}
    }

    /* Lock the file while we read it.  Always unlock it afterwards. */

    myreply = -1;  /* Default is Error. */
    for (;;) {   /* dummy loop so we can exit on errors */

        if (c->LockedWrites) {
            reply = circfint_Lock (c, WRITE_PTR);
            if (reply)  break;
        }

        /* Get up-to-date pointers. */
        reply = circfint_ReadPtrs (c);
        if (reply)  break;

        /* Check that no un-read records overlap the end of the file. */
        if ( c->Ntbw < c->Ntbr ) {
            /* Woops. Do not disturb unread records. */
            if (c->Save_messages) TRACE_SAVE_NEXT (1);
            reply = TRACE (-2,"CIR011F CANNOT RESET MAX_RECORDS. NTBW<NTBR.");
            break;
        }

        /* Check that new file size is beyond ntbw. */
        if ( c->Ntbw >= newmax ) {
            /* Woops. ntbw is beyond eof. */
            if (c->Save_messages) TRACE_SAVE_NEXT (1);
            reply = TRACE (-2,"CIR011F CANNOT RESET MAX_RECORDS. NTBW>=MAX.");
            break;
        }
        
        /* OK to expand the file. */
	/* New pointers were read in, so save newmax again.*/
        c->Max_records = newmax;

        /* Update the file (only overwrites MAX) */
        reply = circfint_WritePtrs (c, OTHER_PTRS);
        if (reply)  break;

        myreply = OK;  /* Success */
        break;
    }

    /* Always unlock the file (regardless of above errors) */
    if (c->LockedWrites) reply2 = circfint_Unlock (c, WRITE_PTR);
    else                 reply2 = 0;
    if (reply)    return (reply);  /* First error seen */
    if (reply2)   return (reply2); /* Unlock error */

    return (myreply);
}
 
/**
* ---------------------------------------------------------------------------
*                                                           CorrectRecordNo
* ---------------------------------------------------------------------------
* Safely correct a record number.
* e.g.  CorrectRecordNo (recordno+1000)
* Used to convert simple arithmetic back into a valid record number.
* Returns:	0-n = a valid record number for this circular file.
*		-1  = error (rare) I/O error
*/
int circfile_CorrectRecordNo (CIRCFILE *c, int record_no) {
	return (circfile_qCorrectN(c,record_no));
}

/**
* ---------------------------------------------------------------------------
*                                                             IncrementMyNtbr
* ---------------------------------------------------------------------------
* Safely increment a private NTBR (Next-to-be-read) pointer.
* Used by 'Lookers' who keep their own record number, and track new data as
* it appears on the circular file.
* Use recordno = -9 to start a fresh 'Looker/follow Ntbw'. 
*   (NTBW-1 will be supplied).
* It caters for the case when a circular file is expanded online,
* (i.e. when MaxRecords has been increased).
* Does not cater for shrinkage (restart your system instead).
* Returns:       0 = success, record number updated.
*               -1 = hard error (and a saved Trace message is stored),
*			record number updated anyway if possible.
*/
int circfile_IncrementMyNtbr (CIRCFILE *c, int *ntbr) {

    return (internal_BumpRecordNo (c, ntbr, 1));
}

/**
* ---------------------------------------------------------------------------
*                                                           IncrementRecordNo
* ---------------------------------------------------------------------------
* Safely increment a record number, until end-of-file is reached.
* Used by 'Forward Serching' until end-of-file.
* Use recordno = -9 to start a fresh 'Search from start'.
*   (NTBW+1 will be supplied).
* It caters for the case when a circular file is expanded online,
* (i.e. when MaxRecords has been increased).
* Does not cater for shrinkage (restart your system instead).
* Returns:       0 = success, record number updated.
*               -2 = soft fail, 'end-of-file'. (no records ready to be read)
*               -1 = hard error (and a saved Trace message is stored)
*/
int circfile_IncrementRecordNo (CIRCFILE *c, int *record_no) {

    return (internal_BumpRecordNo (c, record_no, 0));
}

/**
* ---------------------------------------------------------------------------
*                                         (Internal)         BumpRecordNo
* ---------------------------------------------------------------------------
* Safely increment a record number, depending on who requested it,
*	IncrementNtbr (how=1) or IncrementRecordNo (how=0).
* It caters for the case when a circular file is expanded online,
* (i.e. when MaxRecords has been increased).
* Does not cater for shrinkage (restart your system instead).
* Returns:       0 = success, record number updated.
*               -2 = soft fail, 'end-of-file'. (no records ready to be read)
*               -1 = hard error (and a saved Trace message is stored)
*	See also IncrementNtbr or IncrementRecordNo for 'Returns'.
*/
static int internal_BumpRecordNo (CIRCFILE *c, int *record_no, int how) {

   int old_record_no, new_record_no, reply;
 
    /* Check that we have a correctly initialised structure */
    if (NotInit(c)) return (-1);

    old_record_no = *record_no;

    if (c->Debug) printf (" BumpRecordNo on CIRCFILE: %s.\n",c->Prefix);

    /* Prerequisites. */
    /* The file must be open, so we can check its pointers.*/
    if (c->Cirfile_mode==CLOSED) {
        if (c->Save_messages) TRACE_SAVE_NEXT (1);
        return (TRACE (-1,"CIR004F FILE NOT OPEN YET."));
    }

    /* Special -9 initialisation, depending on caller.*/
    /* (for Ntbr only, exit after setting it to Ntbw).*/
    if (old_record_no == -9) {
	if (how == 0) {
	    /* for IncrementRecordNo: */
	    /* Special case, -9 to start a new forwards search.*/
	    /* Supply NTBW+1.*/
	    /* Grab the latest NTBW. */
            reply = circfint_ReadPtrs (c);
            if (reply)  return (-1);     /* -1, hard error */
	    old_record_no = c->Ntbw;
	    *record_no = old_record_no;  /* it will get incremented soon.*/
	} 
	else {
	    /* for IncrementMyNtbr: */
	    /* Special case, -9 to start a new forwards 'NTBW follower'. */
	    /* Supply NTBW. */
	    /* Grab the latest NTBW. */
            reply = circfint_ReadPtrs (c);
            /* Ignore above 'reply' code, and assume we can use the old Ntbw.*/
	    *record_no = c->Ntbw;
	    return (OK);
	}
    } 

    /* The given pointer should be sensible.*/
    if ((old_record_no<0) || (old_record_no>=c->Max_records)) {
        if (c->Save_messages) TRACE_SAVE_NEXT (1);
        return (TRACE_CHARS (-1,"CIR005F BAD RecordNumber ON: ",c->Prefix));
    }

    /* Only as we wrap around the max, check if file size increased.*/
    if (old_record_no == c->Max_records-1) {
	/* About to wrap past the last record in the file.*/
	/* Recheck Maxrec just in case the file has been expanded online.*/
        /* Get up-to-date pointers. */
        reply = circfint_ReadPtrs (c);
        /* Only exit for IncrementRecordNo. For Ntbr, carry on regardless ! */
        if (how==0) {
            if (reply)  return (-1);	/* -1, hard error */
        }
    }

    /* Now test the updated record number against the (updated) maxrecords.*/
    new_record_no = old_record_no + 1;
    if (new_record_no > c->Max_records-1) new_record_no = 0;

    /* For IncrementRecordNo only, */
    /* If we are already at end-of-file, exit with soft fail.*/
    if (how==0) {
	if (new_record_no == c->Ntbw) return (-2);
    }
    
    /* OK to update the record number.*/
    *record_no = new_record_no;
    return (OK);
}

/**     Safely Decrement record number
* ---------------------------------------------------------------------------
*                                                           DecrementRecordNo
* ---------------------------------------------------------------------------
* Safely Decrement a record number, until start-of-file is reached.
* Used by 'Backward Serching' until start-of-file. (i.e. NTBW+1).
* Use recordno = -9 to start a fresh search. (NTBW-1 will be supplied).
* It caters for the case when a circular file is expanded online,
* (i.e. when MaxRecords has been increased).
* Does not cater for shrinkage (restart/cold-start your system instead).
* Returns:       0 = success, record number updated.
*               -2 = soft fail, 'start-of-file'. (no records ready to be read)
*               -1 = hard error (and a Trace message has been logged)
*/
int circfile_DecrementRecordNo (CIRCFILE *c, int *record_no) {

    int old_record_no, new_record_no, reply;

    /* Check that we have a correctly initialised structure */
    if (NotInit(c)) return (-1);

    old_record_no = *record_no;

    if (c->Debug) printf (" DecrementRecordNo on CIRCFILE: %s.\n",c->Prefix);

    /* Prerequisites. */
    /* The file must be open, so we can check its pointers.*/
    if (c->Cirfile_mode==CLOSED) {
        if (c->Save_messages) TRACE_SAVE_NEXT (1);
        return (TRACE (-1,"CIR004F FILE NOT OPEN YET."));
    }
    /* Special case, -9 to start a new backwards search. Supply NTBW-1. */
    if (old_record_no == -9) {
	/* Grab the latest NTBW. (It will be decremented later.) */
        reply = circfint_ReadPtrs (c);
        if (reply)  return (-1);     /* -1, hard error */
	old_record_no = c->Ntbw;
	*record_no = old_record_no;
    } 
    /* The given pointer should be sensible.*/
    if ((old_record_no<0) || (old_record_no>=c->Max_records)) {
        if (c->Save_messages) TRACE_SAVE_NEXT (1);
        return (TRACE_CHARS (-1,"CIR005F BAD RecordNumber ON: ",c->Prefix));
    }

    /* Only as we wrap around, check file size.*/
    if (old_record_no == 0) {
        /* About to wrap down past zero, up to the last record in the file.*/
        /* Recheck Maxrec just in case the file has been expanded online.*/
        /* Get up-to-date pointers. */
        reply = circfint_ReadPtrs (c);
        if (reply)  return (-1);     /* -1, hard error */
    }

    /* Now try updated record number.*/
    new_record_no = old_record_no - 1;
    if (new_record_no < 0) new_record_no = c->Max_records-1;

    /* If we are already at start-of-file, exit with soft fail.*/
    /* CAREFUL: Ntbw may be advancing past record_no, and this test may fail.*/
    /* What can we do to make it safer ???? */
    if (new_record_no == c->Ntbw) return (-2);

    /* OK to update the record number.*/
    *record_no = new_record_no;
    return (OK);
}


/**	Read & update the files.
* ---------------------------------------------------------------------------
*								ReadUpdate
* ---------------------------------------------------------------------------
* READ the next record from a circular file, and update the ntbr pointer.
* Returns:	 0 = success
*		-2 = soft fail, no data. (no records ready to be read)
*		-1 = hard error (and a saved Trace message is stored)
*/
int circfile_ReadUpdate (CIRCFILE *c, void *data_record) {

    int myreply, reply, reply2;

    /* Check that we have a correctly initialised structure */
    if (NotInit(c)) return (-1);

    if (c->Debug) printf (" Reading/Updating CIRCFILE: %s.\n",c->Prefix);

    /* Only read the record if the request is valid. */
    if (c->Cirfile_mode==CLOSED) {
        if (c->Save_messages) TRACE_SAVE_NEXT (1);
	return (TRACE (-1,"CIR004F FILE NOT OPEN YET."));
    }
    if (c->Cirfile_mode!=READER) {
        if (c->Save_messages) TRACE_SAVE_NEXT (1);
	return (TRACE_CHARS(-1,"CIR002F NOT OPEN FOR ReadUpdate ON: ",c->Prefix));
    }

    /* Lock the file while we read it.  Always unlock it afterwards. */

    myreply = -2;  /* Default is NO DATA. */
    for (;;) {   /* dummy loop so we can exit on errors */

	if (c->LockedReads) {
	    reply = circfint_Lock (c, READ_PTR);
	    if (reply)  break;
	}

	/* Get up-to-date pointers. */
	reply = circfint_ReadPtrs (c);
	if (reply)  break;

	if (c->Ntbr==c->Ntbw)  break;    /* No data */

	reply = circfint_ReadData (c, data_record, c->Ntbr);
	if (reply)  break;

	/* Move the next-to-be-read pointer to the next (un-read) record. */
	c->Ntbr++;
	if (c->Ntbr >= c->Max_records)  c->Ntbr = 0;

	/* Update the file */
	reply = circfint_WritePtrs (c, READ_PTR);
	if (reply)  break;

	myreply = OK;  /* Success */
	break;
    }

    /* Always unlock the file (regardless of above errors) */
    if (c->LockedReads) reply2 = circfint_Unlock (c, READ_PTR);
    else		reply2 = 0;

    if (reply)    return (reply);  /* First error seen */
    if (reply2)   return (reply2); /* Unlock error */
    if (myreply)  return (myreply);
    return (OK);
}

/**
* ---------------------------------------------------------------------------
*								WriteUpdate
* ---------------------------------------------------------------------------
* Write a new record to a circular file, and update the ntbw pointer.
* Returns: 0=OK, -1 = error (and a saved Trace message is stored),
*                -2 = error, file full   (no trace message).
*/
int circfile_WriteUpdate (CIRCFILE *c, void *data_record) {

    int myreply, reply, reply2;

    /* Check that we have a correctly initialised structure */
    if (NotInit(c)) return (-1);

    if (c->Debug) printf (" Writing/Updating CIRCFILE: %s.\n",c->Prefix);

    /* Only write the record if the request is valid. */
    if (c->Cirfile_mode==CLOSED) {
        if (c->Save_messages) TRACE_SAVE_NEXT (1);
	return (TRACE (-1,"CIR004F FILE NOT OPEN YET."));
    }
    if ( (c->Cirfile_mode!=WRITER) && (c->Cirfile_mode!=WRITEONLY) ) {
        if (c->Save_messages) TRACE_SAVE_NEXT (1);
	TRACE_CHARS (-1,"CIR003F NOT OPEN FOR WriteUpdate ON: ",c->Prefix);
        return (-1);
    }

    /* Lock the file while we write it.  Always unlock it afterwards. */
    myreply = -2;  /* default is FULL */
    for (;;) {   /* dummy loop so we can exit on errors */

	if (c->LockedWrites) {
	    reply = circfint_Lock (c, WRITE_PTR);
	    if (reply)  break;
	}

	/* Get up-to-date pointers. */
	reply = circfint_ReadPtrs (c);
	if (reply)  break;

	/* Write the record at next-to-be-written */
	reply = circfint_WriteData (c, data_record, c->Ntbw);
	if (reply)  break;

	/* Move the next-to-be-written pointer to the next record. */
	c->Ntbw++;
	if (c->Ntbw >= c->Max_records)  c->Ntbw = 0;

	/* Error if the file is full */
        /* (only relevant for OpenWriter users, not OpenWriteOnly users.) */
	if ( (c->Cirfile_mode==WRITER) && (c->Ntbw == c->Ntbr) ) break;

	/* Update the file */
	reply = circfint_WritePtrs (c, WRITE_PTR);
	if (reply)  break;

	myreply = OK;  /* Success */
	break;
    }

    /* Always unlock the file (regardless of above errors) */
    if (c->LockedWrites) reply2 = circfint_Unlock (c, WRITE_PTR);
    else		reply2 = 0;

    if (reply)    return (reply);  /* First error seen */
    if (reply2)   return (reply2); /* Unlock error */
    if (myreply)  return (myreply); /* -2=Full file. */
    return (OK);
}

/**
* ---------------------------------------------------------------------------
*								LookRecord
* ---------------------------------------------------------------------------
* Look at a chosen record from a circular file.
*  (i.e. read the file but do not change any pointers).
* Returns: 0=OK, n = error (and a saved Trace message is stored)
*/
int circfile_LookRecord (CIRCFILE *c,
		void *data_record, const int record_number) {

    int reply;

    /* Check that we have a correctly initialised structure */
    if (NotInit(c)) return (-1);

    if (c->Debug) printf (" LookRecord on CIRCFILE: %s.\n",c->Prefix);

    /* Only read the record if the request is valid. */
    if (c->Cirfile_mode==CLOSED) {
        if (c->Save_messages) TRACE_SAVE_NEXT (1);
	return (TRACE (-1,"CIR004F FILE NOT OPEN YET."));
    }

    if (record_number>=c->Max_records) {
    	/* File may have been expanded.*/
    	/* Get up-to-date pointers. */
	reply = circfint_ReadPtrs (c);
	if (reply)  return (reply);
    }
    if ( (record_number<0) || (record_number>=c->Max_records) ) {
      if (c->Save_messages) TRACE_SAVE_NEXT (1);
      TRACE_CHARS (record_number,"CIR005F BAD ReadRecord NUMBER ON: ",c->Prefix);
      return (-1);
    }

    reply = circfint_ReadData (c, data_record, record_number);

    if (reply)  return (reply);
    return (OK);
}

/**
* ---------------------------------------------------------------------------
*								RewriteRecord
* ---------------------------------------------------------------------------
* Rewrite a chosen record in a circular file.
*  (i.e. rewrite the file but do not change any pointers).
* Returns: 0=OK, n = error (and a saved Trace message is stored)
*/
int circfile_RewriteRecord (CIRCFILE *c,
		void *data_record, const int record_number) {

    int reply;

    /* Check that we have a correctly initialised structure */
    if (NotInit(c)) return (-1);

    if (c->Debug) printf (" RewriteRecord on CIRCFILE: %s.\n",c->Prefix);

    /* Only rewrite the record if the request is valid. */
    if (c->Cirfile_mode==CLOSED) {
        if (c->Save_messages) TRACE_SAVE_NEXT (1);
	return (TRACE (-1,"CIR004F FILE NOT OPEN YET."));
    }
    if ( (c->Cirfile_mode!=WRITER) && (c->Cirfile_mode!=WRITEONLY) ) {
        if (c->Save_messages) TRACE_SAVE_NEXT (1);
	TRACE_CHARS (-1,"CIR003F NOT OPEN FOR WriteUpdate ON: ",c->Prefix);
        return (-1);
    }

    if (record_number>=c->Max_records) {
    	/* File may have been expanded.*/
    	/* Get up-to-date pointers. */
	reply = circfint_ReadPtrs (c);
	if (reply)  return (reply);
    }
    
    if ( (record_number<0) || (record_number>=c->Max_records) ) {
      if (c->Save_messages) TRACE_SAVE_NEXT (1);
      TRACE_CHARS (record_number,"CIR005F BAD RewriteRecord NUMBER ON: ",c->Prefix);
      return (-1);
    }

    reply = circfint_WriteData (c, data_record, record_number);

    if (reply)  return (reply);
    return (OK);
}

/* <F><S>	Acknowledge chosen record(s).
* ---------------------------------------------------------------------------
*							AcknowledgeRecord
* ---------------------------------------------------------------------------
* Acknowledge a chosen record from a circular file,
* (pointers only change if the record number corresponds to the Ntbr record).
* This operation provides an inter-locked way of preventing multiple users
* from acknowledging the same record, e.g. when acknowledging alarm messages.
* Returns: 0=OK, n = error (and a saved Trace message is stored)
*/
int circfile_AcknowledgeRecord (CIRCFILE *c,const int record_number) {

    int myreply, reply, reply2;

    /* Check that we have a correctly initialised structure */
    if (NotInit(c)) return (-1);

    if (c->Debug) printf (" Acknowledge numbered record from CIRCFILE: %s.\n",c->Prefix);
    /* Only acknolwegde the record if the request is valid. */
    if (c->Cirfile_mode==CLOSED) {
        if (c->Save_messages) TRACE_SAVE_NEXT (1);
	return (TRACE (-1,"CIR004F FILE NOT OPEN YET."));
    }
    if (c->Cirfile_mode!=READER) {
        if (c->Save_messages) TRACE_SAVE_NEXT (1);
	return (TRACE_CHARS(-1,"CIR002F NOT OPEN FOR ReadUpdate ON: ",c->Prefix));
    }
    if ( (record_number<0) || (record_number>=c->Max_records) ) {
      if (c->Save_messages) TRACE_SAVE_NEXT (1);
      TRACE_CHARS (record_number,"CIR005F BAD AcknowledgeRecord NUMBER ON: ",c->Prefix);
      return (-1);
    }

    /* Lock the file while we read it.  Always unlock it afterwards. */

    myreply = -2;  /* Default is NO DATA (i.e not correct record). */
    for (;;) {   /* dummy loop so we can exit on errors */

	if (c->LockedReads) {
	    reply = circfint_Lock (c, READ_PTR);
	    if (reply)  break;
	}

	/* Get up-to-date pointers. */
	reply = circfint_ReadPtrs (c);
	if (reply)  break;

	if (c->Ntbr==c->Ntbw)  break;    /* No data */

	/* exit if the record numbers don't match */
	if (record_number != c->Ntbr)  break;

	/* Move the next-to-be-read pointer to the next (un-read) record. */
	c->Ntbr++;
	if (c->Ntbr >= c->Max_records)  c->Ntbr = 0;

	/* Update the file */
	reply = circfint_WritePtrs (c, READ_PTR);
	if (reply)  break;

	myreply = OK;  /* Success */
	break;
    }

    /* Always unlock the file (regardless of above errors) */
    if (c->LockedReads) reply2 = circfint_Unlock (c, READ_PTR);
    else		reply2 = 0;
    if (reply)    return (reply);  /* First error seen */
    if (reply2)   return (reply2); /* Unlock error     */

    return (myreply);
}

/**
* ---------------------------------------------------------------------------
*								ReadVarLength
* ---------------------------------------------------------------------------
* READ the next variable-length record from a circular file,
* and update the ntbr pointer.
* (Variable length records are held on file as a many fixed-length records.)
* Returns:	 0 = success
*		-2 = soft fail, no data. (no records ready to be read)
*		-1 = hard error (and a saved Trace message is stored)
*/
int circfile_ReadVarLength (CIRCFILE *c, void *data_record,
						const int vmaxlength) {

    int myreply, reply, reply2, vreclength;

    /* Check that we have a correctly initialised structure */
    if (NotInit(c)) return (-1);

    if (c->Debug) printf (" Reading VarLength CIRCFILE: %s.\n",c->Prefix);

    /* Only read the record if the request is valid. */
    if (c->Cirfile_mode==CLOSED) {
        if (c->Save_messages) TRACE_SAVE_NEXT (1);
	return (TRACE (-1,"CIR004F FILE NOT OPEN YET."));
    }
    if (c->Cirfile_mode!=READER) {
        if (c->Save_messages) TRACE_SAVE_NEXT (1);
	return (TRACE_CHARS(-1,"CIR002F NOT OPEN FOR ReadUpdate ON: ",c->Prefix));
    }

    /* Lock the file while we read it.  Always unlock it afterwards. */

    myreply = -2;  /* Default is NO DATA. */
    for (;;) {   /* dummy loop so we can exit on errors */

	if (c->LockedReads) {
	    reply = circfint_Lock (c, READ_PTR);
	    if (reply)  break;
	}

	/* Get up-to-date pointers. */
	reply = circfint_ReadPtrs (c);
	if (reply)  break;

	if (c->Ntbr==c->Ntbw)  break;    /* No data */

	reply = circfint_ReadVarLenData (c, data_record, vmaxlength, c->Ntbr);
	if (reply<0)  break;
	vreclength = reply;

	/* Move the next-to-be-read pointer to the next (un-read) record. */
	c->Ntbr += circfint_qNfixedLenRecords (vreclength, c->Record_size);
	if (c->Ntbr >= c->Max_records)  c->Ntbr -= c->Max_records;

	/* Update the file */
	reply = circfint_WritePtrs (c, READ_PTR);
	if (reply)  break;

	myreply = OK;  /* Success */
	break;
    }

    /* Always unlock the file (regardless of above errors) */
    if (c->LockedReads) reply2 = circfint_Unlock (c, READ_PTR);
    else		reply2 = 0;

    if (reply)    return (reply);  /* First error seen */
    if (reply2)   return (reply2); /* Unlock error */
    if (myreply)  return (myreply);
    return (vreclength);
}

/**	Write Variable Length record.
* ---------------------------------------------------------------------------
*							WriteVarLength
* ---------------------------------------------------------------------------
* Write a new variable-length record to a circular file,
* and update the ntbw pointer.
* (Variable length records are held on file as a many fixed-length records.)
* Returns: 0=OK, -1 = error (and a saved Trace message is stored),
*                -2 = error, file full   (no trace message).
*/
int circfile_WriteVarLength (CIRCFILE *c, void *data_record,
						const int vreclength) {

    int myreply, reply, reply2, nexttbw, nrecords, room;

    /* Check that we have a correctly initialised structure */
    if (NotInit(c)) return (-1);

    if (c->Debug) printf (" Writing VarLength CIRCFILE: %s.\n",c->Prefix);

    /* Only write the record if the request is valid. */
    if (c->Cirfile_mode==CLOSED) {
        if (c->Save_messages) TRACE_SAVE_NEXT (1);
	return (TRACE (-1,"CIR004F FILE NOT OPEN YET."));
    }
    if ( (c->Cirfile_mode!=WRITER) && (c->Cirfile_mode!=WRITEONLY) ) {
        if (c->Save_messages) TRACE_SAVE_NEXT (1);
	TRACE_CHARS (-1,"CIR003F NOT OPEN FOR WriteVarLength ON: ",c->Prefix);
        return (-1);
    }

    nrecords = circfint_qNfixedLenRecords (vreclength, c->Record_size);
    if (nrecords > 99) {
        if (c->Save_messages) TRACE_SAVE_NEXT (1);
	TRACE_CHARS (-1,"CIR012F VARLENGTH RECORD TOO LONG ON: ",c->Prefix);
        return (-1);
    }

    /* Lock the file while we write it.  Always unlock it afterwards. */
    myreply = -2;  /* default is FULL */
    for (;;) {   /* dummy loop so we can exit on errors */

	if (c->LockedWrites) {
	    reply = circfint_Lock (c, WRITE_PTR);
	    if (reply)  break;
	}

	/* Get up-to-date pointers. */
	reply = circfint_ReadPtrs (c);
	if (reply)  break;

	/* Error if the file is full */
        /* (only relevant for OpenWriter users, not OpenWriteOnly users.) */
	if (c->Cirfile_mode==WRITER) {
	    room = circfile_qNavailable(c);
	    if (nrecords > room) break;
	}

	/* Test-Move the next-to-be-written pointer to the next record. */
	nexttbw = c->Ntbw + nrecords;
	if (nexttbw >= c->Max_records)  nexttbw -= c->Max_records;

	/* Write the record at (the old) next-to-be-written */
	reply = circfint_WriteVarLenData (c, data_record, vreclength);
	if (reply)  break;

	/* Move the real next-to-be-written pointer to the next record. */
	c->Ntbw = nexttbw;

	/* Update the file */
	reply = circfint_WritePtrs (c, WRITE_PTR);
	if (reply)  break;

	myreply = OK;  /* Success */
	break;
    }

    /* Always unlock the file (regardless of above errors) */
    if (c->LockedWrites) reply2 = circfint_Unlock (c, WRITE_PTR);
    else		reply2 = 0;

    if (reply)    return (reply);  /* First error seen */
    if (reply2)   return (reply2); /* Unlock error */
    if (myreply)  return (myreply); /* -2=Full file. */
    return (OK);
}

/**
* ---------------------------------------------------------------------------
*								LookVarLength
* ---------------------------------------------------------------------------
* Look at a chosen variable-length record from a circular file.
*  (i.e. read the file but do not change any pointers).
* (Variable length records are held on file as a many fixed-length records.)
* Returns: 0=OK, n = error (and a saved Trace message is stored)
*/
int circfile_LookVarLength (CIRCFILE *c,
	void *data_record, const int vmaxlength, const int record_number) {

    int reply;

    /* Check that we have a correctly initialised structure */
    if (NotInit(c)) return (-1);

    if (c->Debug) printf (" LookVarLength on CIRCFILE: %s.\n",c->Prefix);

    /* Only read the record if the request is valid. */
    if (c->Cirfile_mode==CLOSED) {
        if (c->Save_messages) TRACE_SAVE_NEXT (1);
	return (TRACE (-1,"CIR004F FILE NOT OPEN YET."));
    }
    if ( (record_number<0) || (record_number>=c->Max_records) ) {
      if (c->Save_messages) TRACE_SAVE_NEXT (1);
      TRACE_CHARS (record_number,"CIR005F BAD ReadRecord NUMBER ON: ",c->Prefix);
      return (-1);
    }

    reply = circfint_ReadVarLenData (c, data_record, vmaxlength, record_number);

    if (reply)  return (reply);
    return (OK);
}

/**	Acknowledge chosen VarLength record.
* ---------------------------------------------------------------------------
*								AckVarLength
* ---------------------------------------------------------------------------
* Acknowledge a chosen variable-length record from a circular file,
* (pointers only change if the record number corresponds to the Ntbr record).
* This operation provides an inter-locked way of preventing multiple users
* from acknowledging the same record, e.g. when acknowledging alarm messages.
* (Variable length records are held on file as a many fixed-length records.)
* Returns: 0=OK, n = error (and a saved Trace message is stored)
*/
int circfile_AckVarLength (CIRCFILE *c, const int record_number,
						const int vreclength) {

    int myreply, reply, reply2;

    /* Check that we have a correctly initialised structure */
    if (NotInit(c)) return (-1);

    if (c->Debug) printf (" Acknowledge numbered VarLengthrecord from CIRCFILE: %s.\n",c->Prefix);
    /* Only acknolwegde the record if the request is valid. */
    if (c->Cirfile_mode==CLOSED) {
        if (c->Save_messages) TRACE_SAVE_NEXT (1);
	return (TRACE (-1,"CIR004F FILE NOT OPEN YET."));
    }
    if (c->Cirfile_mode!=READER) {
        if (c->Save_messages) TRACE_SAVE_NEXT (1);
	return (TRACE_CHARS(-1,"CIR002F NOT OPEN FOR ReadUpdate ON: ",c->Prefix));
    }
    if ( (record_number<0) || (record_number>=c->Max_records) ) {
      if (c->Save_messages) TRACE_SAVE_NEXT (1);
      TRACE_CHARS (record_number,"CIR005F BAD AcknowledgeRecord NUMBER ON: ",c->Prefix);
      return (-1);
    }

    /* Lock the file while we read it.  Always unlock it afterwards. */

    myreply = -2;  /* Default is NO DATA (i.e not correct record). */
    for (;;) {   /* dummy loop so we can exit on errors */

	if (c->LockedReads) {
	    reply = circfint_Lock (c, READ_PTR);
	    if (reply)  break;
	}

	/* Get up-to-date pointers. */
	reply = circfint_ReadPtrs (c);
	if (reply)  break;

	if (c->Ntbr==c->Ntbw)  break;    /* No data */

	/* exit if the record numbers don't match */
	if (record_number != c->Ntbr)  break;

	/* Move the next-to-be-read pointer to the next (un-read) record. */
	c->Ntbr += circfint_qNfixedLenRecords (vreclength, c->Record_size);
	if (c->Ntbr >= c->Max_records)  c->Ntbr -= c->Max_records;

	/* Update the file */
	reply = circfint_WritePtrs (c, READ_PTR);
	if (reply)  break;

	myreply = OK;  /* Success */
	break;
    }

    /* Always unlock the file (regardless of above errors) */
    if (c->LockedReads) reply2 = circfint_Unlock (c, READ_PTR);
    else		reply2 = 0;
    if (reply)    return (reply);  /* First error seen */
    if (reply2)   return (reply2); /* Unlock error     */

    return (myreply);
}

/**
* ---------------------------------------------------------------------------
*							      RefreshPointers
* ---------------------------------------------------------------------------
* Read fresh pointers from the *.PTR file. 
* (This is used by display programs to look at the progress of readers
*  and writers.  Do a RefreshPointers before  qNtbr and qNtbw.) 
* Returns: 0=OK, n = error (and a saved Trace message is stored) 
*/
int circfile_RefreshPointers (CIRCFILE *c) {

    int reply;

    /* Check that we have a correctly initialised structure */
    if (NotInit(c)) return (-1);

    if (c->Debug) printf (" Refreshing pointers from CIRCFILE: %s.\n",c->Prefix);

    /* Only read the record if the request is valid. */
    if (c->Cirfile_mode==CLOSED) {
        if (c->Save_messages) TRACE_SAVE_NEXT (1);
	return (TRACE (-1,"CIR004F FILE NOT OPEN YET."));
    }

    reply = circfint_ReadPtrs (c);
    return (reply);
}
